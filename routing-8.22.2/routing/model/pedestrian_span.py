"""
    Routing API v8

    A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.  # noqa: E501

    The version of the OpenAPI document: 8.22.2
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from routing.model_utils import (  # noqa: F401
    ApiTypeError,
    ModelComposed,
    ModelNormal,
    ModelSimple,
    cached_property,
    change_keys_js_to_python,
    convert_js_args_to_python_args,
    date,
    datetime,
    file_type,
    none_type,
    validate_get_composed_info,
)
from ..model_utils import OpenApiModel
from routing.exceptions import ApiAttributeError


def lazy_import():
    from routing.model.distance import Distance
    from routing.model.dynamic_speed_info import DynamicSpeedInfo
    from routing.model.functional_class import FunctionalClass
    from routing.model.localized_string import LocalizedString
    from routing.model.max_speed import MaxSpeed
    from routing.model.speed import Speed
    globals()['Distance'] = Distance
    globals()['DynamicSpeedInfo'] = DynamicSpeedInfo
    globals()['FunctionalClass'] = FunctionalClass
    globals()['LocalizedString'] = LocalizedString
    globals()['MaxSpeed'] = MaxSpeed
    globals()['Speed'] = Speed


class PedestrianSpan(ModelNormal):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Attributes:
      allowed_values (dict): The key is the tuple path to the attribute
          and the for var_name this is (var_name,). The value is a dict
          with a capitalized key describing the allowed value and an allowed
          value. These dicts store the allowed enum values.
      attribute_map (dict): The key is attribute name
          and the value is json key in definition.
      discriminator_value_class_map (dict): A dict to go from the discriminator
          variable value to the discriminator class name.
      validations (dict): The key is the tuple path to the attribute
          and the for var_name this is (var_name,). The value is a dict
          that stores validations for max_length, min_length, max_items,
          min_items, exclusive_maximum, inclusive_maximum, exclusive_minimum,
          inclusive_minimum, and regex.
      additional_properties_type (tuple): A tuple of classes accepted
          as additional properties values.
    """

    allowed_values = {
    }

    validations = {
        ('offset',): {
            'inclusive_minimum': 0,
        },
    }

    @cached_property
    def additional_properties_type():
        """
        This must be a method because a model may have properties that are
        of type self, this must run after the class is loaded
        """
        lazy_import()
        return (bool, date, datetime, dict, float, int, list, str, none_type,)  # noqa: E501

    _nullable = False

    @cached_property
    def openapi_types():
        """
        This must be a method because a model may have properties that are
        of type self, this must run after the class is loaded

        Returns
            openapi_types (dict): The key is attribute name
                and the value is attribute type.
        """
        lazy_import()
        return {
            'offset': (int,),  # noqa: E501
            'length': (Distance,),  # noqa: E501
            'duration': (int,),  # noqa: E501
            'street_attributes': ([str],),  # noqa: E501
            'walk_attributes': ([str],),  # noqa: E501
            'car_attributes': ([str],),  # noqa: E501
            'truck_attributes': ([str],),  # noqa: E501
            'scooter_attributes': ([str],),  # noqa: E501
            'names': ([LocalizedString],),  # noqa: E501
            'route_numbers': ([LocalizedString],),  # noqa: E501
            'country_code': (str,),  # noqa: E501
            'functional_class': (FunctionalClass,),  # noqa: E501
            'speed_limit': (Speed,),  # noqa: E501
            'max_speed': (MaxSpeed,),  # noqa: E501
            'dynamic_speed_info': (DynamicSpeedInfo,),  # noqa: E501
            'segment_id': (str,),  # noqa: E501
            'segment_ref': (str,),  # noqa: E501
            'base_duration': (int,),  # noqa: E501
            'incidents': ([int],),  # noqa: E501
        }

    @cached_property
    def discriminator():
        return None


    attribute_map = {
        'offset': 'offset',  # noqa: E501
        'length': 'length',  # noqa: E501
        'duration': 'duration',  # noqa: E501
        'street_attributes': 'streetAttributes',  # noqa: E501
        'walk_attributes': 'walkAttributes',  # noqa: E501
        'car_attributes': 'carAttributes',  # noqa: E501
        'truck_attributes': 'truckAttributes',  # noqa: E501
        'scooter_attributes': 'scooterAttributes',  # noqa: E501
        'names': 'names',  # noqa: E501
        'route_numbers': 'routeNumbers',  # noqa: E501
        'country_code': 'countryCode',  # noqa: E501
        'functional_class': 'functionalClass',  # noqa: E501
        'speed_limit': 'speedLimit',  # noqa: E501
        'max_speed': 'maxSpeed',  # noqa: E501
        'dynamic_speed_info': 'dynamicSpeedInfo',  # noqa: E501
        'segment_id': 'segmentId',  # noqa: E501
        'segment_ref': 'segmentRef',  # noqa: E501
        'base_duration': 'baseDuration',  # noqa: E501
        'incidents': 'incidents',  # noqa: E501
    }

    read_only_vars = {
    }

    _composed_schemas = {}

    @classmethod
    @convert_js_args_to_python_args
    def _from_openapi_data(cls, *args, **kwargs):  # noqa: E501
        """PedestrianSpan - a model defined in OpenAPI

        Keyword Args:
            _check_type (bool): if True, values for parameters in openapi_types
                                will be type checked and a TypeError will be
                                raised if the wrong type is input.
                                Defaults to True
            _path_to_item (tuple/list): This is a list of keys or values to
                                drill down to the model in received_data
                                when deserializing a response
            _spec_property_naming (bool): True if the variable names in the input data
                                are serialized names, as specified in the OpenAPI document.
                                False if the variable names in the input data
                                are pythonic names, e.g. snake case (default)
            _configuration (Configuration): the instance to use when
                                deserializing a file_type parameter.
                                If passed, type conversion is attempted
                                If omitted no type conversion is done.
            _visited_composed_classes (tuple): This stores a tuple of
                                classes that we have traveled through so that
                                if we see that class again we will not use its
                                discriminator again.
                                When traveling through a discriminator, the
                                composed schema that is
                                is traveled through is added to this set.
                                For example if Animal has a discriminator
                                petType and we pass in "Dog", and the class Dog
                                allOf includes Animal, we move through Animal
                                once using the discriminator, and pick Dog.
                                Then in Dog, we will make an instance of the
                                Animal class but this time we won't travel
                                through its discriminator because we passed in
                                _visited_composed_classes = (Animal,)
            offset (int): Offset of a coordinate in the section's polyline. . [optional]  # noqa: E501
            length (Distance): [optional]  # noqa: E501
            duration (int): Duration in seconds.. [optional]  # noqa: E501
            street_attributes ([str]): `StreetAttributes` is applied to a span of a route section and describes attribute flags of a street. * `rightDrivingSide`: Do vehicles have to drive on the right-hand side of the road or the left-hand side. * `dirtRoad`: This part of the route has an un-paved surface. * `tunnel`: This part of the route is a tunnel. * `bridge`: This part of the route is a bridge. * `ramp`: This part of the route is a ramp (usually connecting to/from/between highways). * `motorway`: This part of the route is a controlled access road (usually highways). * `roundabout`: This part of the route is a roundabout. * `underConstruction`: This part of the route is under construction. * `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle. * `privateRoad`: This part of the route uses a privately owned road.  As it is possible that new street attributes are supported in the future, unknown street attributes should be ignored. . [optional]  # noqa: E501
            walk_attributes ([str]): Accessibility and walk-related attribute flags.  * `stairs`: This part of the route is a staircase. * `park`: This part of the route is in a park. * `indoor`: This part of the route is inside a venue. * `open`:  Describes whether this part of the route can be traversed. * `noThrough`:  A part of the route you can only enter if your destination is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new attributes are supported in the future, unknown attributes should be ignored. . [optional]  # noqa: E501
            car_attributes ([str]): Car specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  Describes if you are allowed to traverse this stretch of the route. * `noThrough`:  A part of the route you can only enter if your destination is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored. . [optional]  # noqa: E501
            truck_attributes ([str]): Truck specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  This part of the route is open to trucks. * `noThrough`:  This part of the route can only be entered if the destination is located there. * `tollRoad`: This part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored. . [optional]  # noqa: E501
            scooter_attributes ([str]): Scooter specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  This part of the route is open to scooters.  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored. . [optional]  # noqa: E501
            names ([LocalizedString]): Designated name for the span (e.g. a street name or a transport name). [optional]  # noqa: E501
            route_numbers ([LocalizedString]): Designated route name or number of the span (e.g. 'M25'). [optional]  # noqa: E501
            country_code (str): ISO-3166-1 alpha-3 code. [optional]  # noqa: E501
            functional_class (FunctionalClass): [optional]  # noqa: E501
            speed_limit (Speed): [optional]  # noqa: E501
            max_speed (MaxSpeed): [optional]  # noqa: E501
            dynamic_speed_info (DynamicSpeedInfo): [optional]  # noqa: E501
            segment_id (str): **Disclaimer: This property is currently in beta release, and is therefore subject to breaking changes.**  The directed topology segment id including prefix (e.g '+here:cm:segment:').  The id consists of two parts. * The direction ('+' or '-') * followed by the topology segment id (a unique identifier within the HERE platform catalogs).  The direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction). . [optional]  # noqa: E501
            segment_ref (str): A reference to the HMC topology segment used in this span.  The standard representation of a segment reference has the following structure: {catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?  The individual parts are: * catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2 * catalogVersion: The catalog version * layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry * tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexidecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>) * segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195 * direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service) * startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1  Example of a segment reference in standard representation: hrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1  The segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section. The placeholder format is \\$\\d+ and need to be surrounded by columns or string start/end. It can be captured with the following regular expression: (^|:)\\$\\d+(:|$)  Example of the segment reference previously mentioned in compact representation: $0:377894441:$1:84905195#+0.7..1 With the corresponding refReplacements: \"refReplacements\": {   \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",   \"1\": \"here:cm:segment\" } . [optional]  # noqa: E501
            base_duration (int): Duration in seconds.. [optional]  # noqa: E501
            incidents ([int]): A list of indices into the incident array of the parent section. References all incidents that apply to the span. . [optional]  # noqa: E501
        """

        _check_type = kwargs.pop('_check_type', True)
        _spec_property_naming = kwargs.pop('_spec_property_naming', False)
        _path_to_item = kwargs.pop('_path_to_item', ())
        _configuration = kwargs.pop('_configuration', None)
        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())

        self = super(OpenApiModel, cls).__new__(cls)

        if args:
            raise ApiTypeError(
                "Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments." % (
                    args,
                    self.__class__.__name__,
                ),
                path_to_item=_path_to_item,
                valid_classes=(self.__class__,),
            )

        self._data_store = {}
        self._check_type = _check_type
        self._spec_property_naming = _spec_property_naming
        self._path_to_item = _path_to_item
        self._configuration = _configuration
        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)

        for var_name, var_value in kwargs.items():
            if var_name not in self.attribute_map and \
                        self._configuration is not None and \
                        self._configuration.discard_unknown_keys and \
                        self.additional_properties_type is None:
                # discard variable.
                continue
            setattr(self, var_name, var_value)
        return self

    required_properties = set([
        '_data_store',
        '_check_type',
        '_spec_property_naming',
        '_path_to_item',
        '_configuration',
        '_visited_composed_classes',
    ])

    @convert_js_args_to_python_args
    def __init__(self, *args, **kwargs):  # noqa: E501
        """PedestrianSpan - a model defined in OpenAPI

        Keyword Args:
            _check_type (bool): if True, values for parameters in openapi_types
                                will be type checked and a TypeError will be
                                raised if the wrong type is input.
                                Defaults to True
            _path_to_item (tuple/list): This is a list of keys or values to
                                drill down to the model in received_data
                                when deserializing a response
            _spec_property_naming (bool): True if the variable names in the input data
                                are serialized names, as specified in the OpenAPI document.
                                False if the variable names in the input data
                                are pythonic names, e.g. snake case (default)
            _configuration (Configuration): the instance to use when
                                deserializing a file_type parameter.
                                If passed, type conversion is attempted
                                If omitted no type conversion is done.
            _visited_composed_classes (tuple): This stores a tuple of
                                classes that we have traveled through so that
                                if we see that class again we will not use its
                                discriminator again.
                                When traveling through a discriminator, the
                                composed schema that is
                                is traveled through is added to this set.
                                For example if Animal has a discriminator
                                petType and we pass in "Dog", and the class Dog
                                allOf includes Animal, we move through Animal
                                once using the discriminator, and pick Dog.
                                Then in Dog, we will make an instance of the
                                Animal class but this time we won't travel
                                through its discriminator because we passed in
                                _visited_composed_classes = (Animal,)
            offset (int): Offset of a coordinate in the section's polyline. . [optional]  # noqa: E501
            length (Distance): [optional]  # noqa: E501
            duration (int): Duration in seconds.. [optional]  # noqa: E501
            street_attributes ([str]): `StreetAttributes` is applied to a span of a route section and describes attribute flags of a street. * `rightDrivingSide`: Do vehicles have to drive on the right-hand side of the road or the left-hand side. * `dirtRoad`: This part of the route has an un-paved surface. * `tunnel`: This part of the route is a tunnel. * `bridge`: This part of the route is a bridge. * `ramp`: This part of the route is a ramp (usually connecting to/from/between highways). * `motorway`: This part of the route is a controlled access road (usually highways). * `roundabout`: This part of the route is a roundabout. * `underConstruction`: This part of the route is under construction. * `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle. * `privateRoad`: This part of the route uses a privately owned road.  As it is possible that new street attributes are supported in the future, unknown street attributes should be ignored. . [optional]  # noqa: E501
            walk_attributes ([str]): Accessibility and walk-related attribute flags.  * `stairs`: This part of the route is a staircase. * `park`: This part of the route is in a park. * `indoor`: This part of the route is inside a venue. * `open`:  Describes whether this part of the route can be traversed. * `noThrough`:  A part of the route you can only enter if your destination is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new attributes are supported in the future, unknown attributes should be ignored. . [optional]  # noqa: E501
            car_attributes ([str]): Car specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  Describes if you are allowed to traverse this stretch of the route. * `noThrough`:  A part of the route you can only enter if your destination is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored. . [optional]  # noqa: E501
            truck_attributes ([str]): Truck specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  This part of the route is open to trucks. * `noThrough`:  This part of the route can only be entered if the destination is located there. * `tollRoad`: This part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored. . [optional]  # noqa: E501
            scooter_attributes ([str]): Scooter specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  This part of the route is open to scooters.  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored. . [optional]  # noqa: E501
            names ([LocalizedString]): Designated name for the span (e.g. a street name or a transport name). [optional]  # noqa: E501
            route_numbers ([LocalizedString]): Designated route name or number of the span (e.g. 'M25'). [optional]  # noqa: E501
            country_code (str): ISO-3166-1 alpha-3 code. [optional]  # noqa: E501
            functional_class (FunctionalClass): [optional]  # noqa: E501
            speed_limit (Speed): [optional]  # noqa: E501
            max_speed (MaxSpeed): [optional]  # noqa: E501
            dynamic_speed_info (DynamicSpeedInfo): [optional]  # noqa: E501
            segment_id (str): **Disclaimer: This property is currently in beta release, and is therefore subject to breaking changes.**  The directed topology segment id including prefix (e.g '+here:cm:segment:').  The id consists of two parts. * The direction ('+' or '-') * followed by the topology segment id (a unique identifier within the HERE platform catalogs).  The direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction). . [optional]  # noqa: E501
            segment_ref (str): A reference to the HMC topology segment used in this span.  The standard representation of a segment reference has the following structure: {catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?  The individual parts are: * catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2 * catalogVersion: The catalog version * layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry * tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexidecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>) * segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195 * direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service) * startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1  Example of a segment reference in standard representation: hrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1  The segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section. The placeholder format is \\$\\d+ and need to be surrounded by columns or string start/end. It can be captured with the following regular expression: (^|:)\\$\\d+(:|$)  Example of the segment reference previously mentioned in compact representation: $0:377894441:$1:84905195#+0.7..1 With the corresponding refReplacements: \"refReplacements\": {   \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",   \"1\": \"here:cm:segment\" } . [optional]  # noqa: E501
            base_duration (int): Duration in seconds.. [optional]  # noqa: E501
            incidents ([int]): A list of indices into the incident array of the parent section. References all incidents that apply to the span. . [optional]  # noqa: E501
        """

        _check_type = kwargs.pop('_check_type', True)
        _spec_property_naming = kwargs.pop('_spec_property_naming', False)
        _path_to_item = kwargs.pop('_path_to_item', ())
        _configuration = kwargs.pop('_configuration', None)
        _visited_composed_classes = kwargs.pop('_visited_composed_classes', ())

        if args:
            raise ApiTypeError(
                "Invalid positional arguments=%s passed to %s. Remove those invalid positional arguments." % (
                    args,
                    self.__class__.__name__,
                ),
                path_to_item=_path_to_item,
                valid_classes=(self.__class__,),
            )

        self._data_store = {}
        self._check_type = _check_type
        self._spec_property_naming = _spec_property_naming
        self._path_to_item = _path_to_item
        self._configuration = _configuration
        self._visited_composed_classes = _visited_composed_classes + (self.__class__,)

        for var_name, var_value in kwargs.items():
            if var_name not in self.attribute_map and \
                        self._configuration is not None and \
                        self._configuration.discard_unknown_keys and \
                        self.additional_properties_type is None:
                # discard variable.
                continue
            setattr(self, var_name, var_value)
            if var_name in self.read_only_vars:
                raise ApiAttributeError(f"`{var_name}` is a read-only attribute. Use `from_openapi_data` to instantiate "
                                     f"class with read only attributes.")
