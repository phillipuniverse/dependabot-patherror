"""
    Routing API v8

    A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.  # noqa: E501

    The version of the OpenAPI document: 8.22.2
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from routing.api_client import ApiClient, Endpoint as _Endpoint
from routing.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from routing.model.auth_error_response_schema import AuthErrorResponseSchema
from routing.model.avoid import Avoid
from routing.model.calculate_routes_parameters import CalculateRoutesParameters
from routing.model.ev import EV
from routing.model.exclude import Exclude
from routing.model.get_routes_by_handle_parameters import GetRoutesByHandleParameters
from routing.model.match_trace import MatchTrace
from routing.model.model_return import ModelReturn
from routing.model.pedestrian_speed import PedestrianSpeed
from routing.model.router_mode import RouterMode
from routing.model.router_route_response import RouterRouteResponse
from routing.model.routing_error_response import RoutingErrorResponse
from routing.model.routing_mode import RoutingMode
from routing.model.scooter import Scooter
from routing.model.spans import Spans
from routing.model.truck import Truck
from routing.model.units import Units
from routing.model.vehicle import Vehicle


class RoutingApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.calculate_routes_endpoint = _Endpoint(
            settings={
                'response_type': (RouterRouteResponse,),
                'auth': [
                    'apiKey',
                    'bearerAuth'
                ],
                'endpoint_path': '/routes',
                'operation_id': 'calculate_routes',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'transport_mode',
                    'origin',
                    'destination',
                    'via',
                    'departure_time',
                    'routing_mode',
                    'alternatives',
                    'avoid',
                    'exclude',
                    'units',
                    'lang',
                    '_return',
                    'spans',
                    'truck',
                    'ev',
                    'vehicle',
                    'pedestrian_speed',
                    'x_request_id',
                    'scooter',
                    'currency',
                ],
                'required': [
                    'transport_mode',
                    'origin',
                    'destination',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'alternatives',
                    '_return',
                    'spans',
                ]
            },
            root_map={
                'validations': {
                    ('alternatives',): {

                        'inclusive_maximum': 6,
                        'inclusive_minimum': 0,
                    },
                    ('_return',): {

                    },
                    ('spans',): {

                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'transport_mode':
                        (RouterMode,),
                    'origin':
                        (str,),
                    'destination':
                        (str,),
                    'via':
                        ([str],),
                    'departure_time':
                        (str,),
                    'routing_mode':
                        (RoutingMode,),
                    'alternatives':
                        (int,),
                    'avoid':
                        (Avoid,),
                    'exclude':
                        (Exclude,),
                    'units':
                        (Units,),
                    'lang':
                        (str,),
                    '_return':
                        ([ModelReturn],),
                    'spans':
                        ([Spans],),
                    'truck':
                        (Truck,),
                    'ev':
                        (EV,),
                    'vehicle':
                        (Vehicle,),
                    'pedestrian_speed':
                        (PedestrianSpeed,),
                    'x_request_id':
                        (str,),
                    'scooter':
                        (Scooter,),
                    'currency':
                        (str,),
                },
                'attribute_map': {
                    'transport_mode': 'transportMode',
                    'origin': 'origin',
                    'destination': 'destination',
                    'via': 'via',
                    'departure_time': 'departureTime',
                    'routing_mode': 'routingMode',
                    'alternatives': 'alternatives',
                    'avoid': 'avoid',
                    'exclude': 'exclude',
                    'units': 'units',
                    'lang': 'lang',
                    '_return': 'return',
                    'spans': 'spans',
                    'truck': 'truck',
                    'ev': 'ev',
                    'vehicle': 'vehicle',
                    'pedestrian_speed': 'pedestrian[speed]',
                    'x_request_id': 'X-Request-ID',
                    'scooter': 'scooter',
                    'currency': 'currency',
                },
                'location_map': {
                    'transport_mode': 'query',
                    'origin': 'query',
                    'destination': 'query',
                    'via': 'query',
                    'departure_time': 'query',
                    'routing_mode': 'query',
                    'alternatives': 'query',
                    'avoid': 'query',
                    'exclude': 'query',
                    'units': 'query',
                    'lang': 'query',
                    '_return': 'query',
                    'spans': 'query',
                    'truck': 'query',
                    'ev': 'query',
                    'vehicle': 'query',
                    'pedestrian_speed': 'query',
                    'x_request_id': 'header',
                    'scooter': 'query',
                    'currency': 'query',
                },
                'collection_format_map': {
                    'via': 'multi',
                    '_return': 'csv',
                    'spans': 'csv',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.calculate_routes_post_endpoint = _Endpoint(
            settings={
                'response_type': (RouterRouteResponse,),
                'auth': [
                    'apiKey',
                    'bearerAuth'
                ],
                'endpoint_path': '/routes',
                'operation_id': 'calculate_routes_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'transport_mode',
                    'origin',
                    'destination',
                    'via',
                    'departure_time',
                    'routing_mode',
                    'alternatives',
                    'avoid',
                    'exclude',
                    'units',
                    'lang',
                    '_return',
                    'spans',
                    'truck',
                    'ev',
                    'vehicle',
                    'pedestrian_speed',
                    'x_request_id',
                    'scooter',
                    'calculate_routes_parameters',
                ],
                'required': [
                    'transport_mode',
                    'origin',
                    'destination',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'alternatives',
                    '_return',
                    'spans',
                ]
            },
            root_map={
                'validations': {
                    ('alternatives',): {

                        'inclusive_maximum': 6,
                        'inclusive_minimum': 0,
                    },
                    ('_return',): {

                    },
                    ('spans',): {

                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'transport_mode':
                        (RouterMode,),
                    'origin':
                        (str,),
                    'destination':
                        (str,),
                    'via':
                        ([str],),
                    'departure_time':
                        (str,),
                    'routing_mode':
                        (RoutingMode,),
                    'alternatives':
                        (int,),
                    'avoid':
                        (Avoid,),
                    'exclude':
                        (Exclude,),
                    'units':
                        (Units,),
                    'lang':
                        (str,),
                    '_return':
                        ([ModelReturn],),
                    'spans':
                        ([Spans],),
                    'truck':
                        (Truck,),
                    'ev':
                        (EV,),
                    'vehicle':
                        (Vehicle,),
                    'pedestrian_speed':
                        (PedestrianSpeed,),
                    'x_request_id':
                        (str,),
                    'scooter':
                        (Scooter,),
                    'calculate_routes_parameters':
                        (CalculateRoutesParameters,),
                },
                'attribute_map': {
                    'transport_mode': 'transportMode',
                    'origin': 'origin',
                    'destination': 'destination',
                    'via': 'via',
                    'departure_time': 'departureTime',
                    'routing_mode': 'routingMode',
                    'alternatives': 'alternatives',
                    'avoid': 'avoid',
                    'exclude': 'exclude',
                    'units': 'units',
                    'lang': 'lang',
                    '_return': 'return',
                    'spans': 'spans',
                    'truck': 'truck',
                    'ev': 'ev',
                    'vehicle': 'vehicle',
                    'pedestrian_speed': 'pedestrian[speed]',
                    'x_request_id': 'X-Request-ID',
                    'scooter': 'scooter',
                },
                'location_map': {
                    'transport_mode': 'query',
                    'origin': 'query',
                    'destination': 'query',
                    'via': 'query',
                    'departure_time': 'query',
                    'routing_mode': 'query',
                    'alternatives': 'query',
                    'avoid': 'query',
                    'exclude': 'query',
                    'units': 'query',
                    'lang': 'query',
                    '_return': 'query',
                    'spans': 'query',
                    'truck': 'query',
                    'ev': 'query',
                    'vehicle': 'query',
                    'pedestrian_speed': 'query',
                    'x_request_id': 'header',
                    'scooter': 'query',
                    'calculate_routes_parameters': 'body',
                },
                'collection_format_map': {
                    'via': 'multi',
                    '_return': 'csv',
                    'spans': 'csv',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_routes_by_handle_endpoint = _Endpoint(
            settings={
                'response_type': (RouterRouteResponse,),
                'auth': [
                    'apiKey',
                    'bearerAuth'
                ],
                'endpoint_path': '/routes/{routeHandle}',
                'operation_id': 'get_routes_by_handle',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'route_handle',
                    'transport_mode',
                    'origin',
                    'departure_time',
                    'avoid',
                    'exclude',
                    'units',
                    'lang',
                    '_return',
                    'spans',
                    'truck',
                    'ev',
                    'vehicle',
                    'x_request_id',
                    'scooter',
                ],
                'required': [
                    'route_handle',
                    'transport_mode',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    '_return',
                    'spans',
                ]
            },
            root_map={
                'validations': {
                    ('_return',): {

                    },
                    ('spans',): {

                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'route_handle':
                        (str,),
                    'transport_mode':
                        (RouterMode,),
                    'origin':
                        (str,),
                    'departure_time':
                        (str,),
                    'avoid':
                        (Avoid,),
                    'exclude':
                        (Exclude,),
                    'units':
                        (Units,),
                    'lang':
                        (str,),
                    '_return':
                        ([ModelReturn],),
                    'spans':
                        ([Spans],),
                    'truck':
                        (Truck,),
                    'ev':
                        (EV,),
                    'vehicle':
                        (Vehicle,),
                    'x_request_id':
                        (str,),
                    'scooter':
                        (Scooter,),
                },
                'attribute_map': {
                    'route_handle': 'routeHandle',
                    'transport_mode': 'transportMode',
                    'origin': 'origin',
                    'departure_time': 'departureTime',
                    'avoid': 'avoid',
                    'exclude': 'exclude',
                    'units': 'units',
                    'lang': 'lang',
                    '_return': 'return',
                    'spans': 'spans',
                    'truck': 'truck',
                    'ev': 'ev',
                    'vehicle': 'vehicle',
                    'x_request_id': 'X-Request-ID',
                    'scooter': 'scooter',
                },
                'location_map': {
                    'route_handle': 'path',
                    'transport_mode': 'query',
                    'origin': 'query',
                    'departure_time': 'query',
                    'avoid': 'query',
                    'exclude': 'query',
                    'units': 'query',
                    'lang': 'query',
                    '_return': 'query',
                    'spans': 'query',
                    'truck': 'query',
                    'ev': 'query',
                    'vehicle': 'query',
                    'x_request_id': 'header',
                    'scooter': 'query',
                },
                'collection_format_map': {
                    '_return': 'csv',
                    'spans': 'csv',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_routes_by_handle_post_endpoint = _Endpoint(
            settings={
                'response_type': (RouterRouteResponse,),
                'auth': [
                    'apiKey',
                    'bearerAuth'
                ],
                'endpoint_path': '/routes/{routeHandle}',
                'operation_id': 'get_routes_by_handle_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'route_handle',
                    'transport_mode',
                    'origin',
                    'departure_time',
                    'avoid',
                    'exclude',
                    'units',
                    'lang',
                    '_return',
                    'spans',
                    'truck',
                    'ev',
                    'vehicle',
                    'x_request_id',
                    'scooter',
                    'get_routes_by_handle_parameters',
                ],
                'required': [
                    'route_handle',
                    'transport_mode',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    '_return',
                    'spans',
                ]
            },
            root_map={
                'validations': {
                    ('_return',): {

                    },
                    ('spans',): {

                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'route_handle':
                        (str,),
                    'transport_mode':
                        (RouterMode,),
                    'origin':
                        (str,),
                    'departure_time':
                        (str,),
                    'avoid':
                        (Avoid,),
                    'exclude':
                        (Exclude,),
                    'units':
                        (Units,),
                    'lang':
                        (str,),
                    '_return':
                        ([ModelReturn],),
                    'spans':
                        ([Spans],),
                    'truck':
                        (Truck,),
                    'ev':
                        (EV,),
                    'vehicle':
                        (Vehicle,),
                    'x_request_id':
                        (str,),
                    'scooter':
                        (Scooter,),
                    'get_routes_by_handle_parameters':
                        (GetRoutesByHandleParameters,),
                },
                'attribute_map': {
                    'route_handle': 'routeHandle',
                    'transport_mode': 'transportMode',
                    'origin': 'origin',
                    'departure_time': 'departureTime',
                    'avoid': 'avoid',
                    'exclude': 'exclude',
                    'units': 'units',
                    'lang': 'lang',
                    '_return': 'return',
                    'spans': 'spans',
                    'truck': 'truck',
                    'ev': 'ev',
                    'vehicle': 'vehicle',
                    'x_request_id': 'X-Request-ID',
                    'scooter': 'scooter',
                },
                'location_map': {
                    'route_handle': 'path',
                    'transport_mode': 'query',
                    'origin': 'query',
                    'departure_time': 'query',
                    'avoid': 'query',
                    'exclude': 'query',
                    'units': 'query',
                    'lang': 'query',
                    '_return': 'query',
                    'spans': 'query',
                    'truck': 'query',
                    'ev': 'query',
                    'vehicle': 'query',
                    'x_request_id': 'header',
                    'scooter': 'query',
                    'get_routes_by_handle_parameters': 'body',
                },
                'collection_format_map': {
                    '_return': 'csv',
                    'spans': 'csv',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.import_route_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'apiKey',
                    'bearerAuth'
                ],
                'endpoint_path': '/import',
                'operation_id': 'import_route',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'transport_mode',
                    'departure_time',
                    'avoid',
                    'exclude',
                    'units',
                    'lang',
                    '_return',
                    'spans',
                    'truck',
                    'ev',
                    'vehicle',
                    'x_request_id',
                    'scooter',
                    'match_trace',
                ],
                'required': [
                    'transport_mode',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    '_return',
                    'spans',
                ]
            },
            root_map={
                'validations': {
                    ('_return',): {

                    },
                    ('spans',): {

                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'transport_mode':
                        (RouterMode,),
                    'departure_time':
                        (str,),
                    'avoid':
                        (Avoid,),
                    'exclude':
                        (Exclude,),
                    'units':
                        (Units,),
                    'lang':
                        (str,),
                    '_return':
                        ([ModelReturn],),
                    'spans':
                        ([Spans],),
                    'truck':
                        (Truck,),
                    'ev':
                        (EV,),
                    'vehicle':
                        (Vehicle,),
                    'x_request_id':
                        (str,),
                    'scooter':
                        (Scooter,),
                    'match_trace':
                        (MatchTrace,),
                },
                'attribute_map': {
                    'transport_mode': 'transportMode',
                    'departure_time': 'departureTime',
                    'avoid': 'avoid',
                    'exclude': 'exclude',
                    'units': 'units',
                    'lang': 'lang',
                    '_return': 'return',
                    'spans': 'spans',
                    'truck': 'truck',
                    'ev': 'ev',
                    'vehicle': 'vehicle',
                    'x_request_id': 'X-Request-ID',
                    'scooter': 'scooter',
                },
                'location_map': {
                    'transport_mode': 'query',
                    'departure_time': 'query',
                    'avoid': 'query',
                    'exclude': 'query',
                    'units': 'query',
                    'lang': 'query',
                    '_return': 'query',
                    'spans': 'query',
                    'truck': 'query',
                    'ev': 'query',
                    'vehicle': 'query',
                    'x_request_id': 'header',
                    'scooter': 'query',
                    'match_trace': 'body',
                },
                'collection_format_map': {
                    '_return': 'csv',
                    'spans': 'csv',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json',
                    'application/geo+json'
                ]
            },
            api_client=api_client
        )

    def calculate_routes(
        self,
        transport_mode,
        origin,
        destination,
        **kwargs
    ):
        """Calculate routes via GET  # noqa: E501

        Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.calculate_routes(transport_mode, origin, destination, async_req=True)
        >>> result = thread.get()

        Args:
            transport_mode (RouterMode): Mode of transport to be used for the calculation of the route.  Note: `taxi` and `bus` modes are in Alpha state. They are not yet stable and behaviour may change drastically, or even become unsupported, without warning. `taxi` and `bus` modes take into account taxi/bus restricted streets as well as streets reserved for exclusive taxi/bus access. It does not, however, consider exclusive lanes in otherwise shared streets. Also, the streets that are for exclusive access for taxi/bus are used only if either the origin or destination are on them. 
            origin (str): A location defining the origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Asks the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 
            destination (str): A location defining the destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Asks the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. * `passThrough`: option is not supported for 'destination'.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 

        Keyword Args:
            via ([str]): A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  Multiple waypoints can also be specified using multiple via parameters like `via=...&via=...`, in which case the route will traverse these waypoints sequentially in the order specified in the request.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Asks the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Supported waypoint options: * `stopDuration`: desired duration for the stop, in seconds. * `passThrough`: boolean. Asks the router to avoid the following during route calculation:   + Introducing a stop at the waypoint.   + Splitting the route into sections.   + Changing the direction of travel.    Following scenarios are not supported for `passThrough` parameter:   + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.   + Setting `passThrough=true` for `origin` or `destination` of a route.   The default value is `false`.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. . [optional]
            departure_time (str): Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. . [optional]
            routing_mode (RoutingMode): Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance.  Notes: * The following Transport modes only support `fast` routingMode   - `bicycle`   - `bus`   - `pedestrian`   - `scooter`   - `taxi` . [optional]
            alternatives (int): Number of alternative routes to return aside from the optimal route.. [optional] if omitted the server will use the default value of 0
            avoid (Avoid): Avoid routes that violate certain features of road network or that go through user-specified geographical bounding boxes.  Note that if the origin, destination, or any via is in an avoided area or on an avoided feature, a route is produced that violates the avoid restriction. In such a case, the route is trying to minimize the violation of the avoid restrictions and can therefore include large deviations from a route that is calculated without these avoid restrictions.  It is also possible that the produced route violates the avoid restriction in between waypoints, if no other route is possible or too hard to find. One such example is requesting a route to an island that is only reachable with ferries while specifying `avoid[features]=ferry`.  Further, avoid can cause the route calculation to fail, if no route is possible or too hard to find.  Specify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel`. . [optional]
            exclude (Exclude): Defines properties which will be strictly excluded from route calculation. . [optional]
            units (Units): Units of measurement used in guidance instructions. The default is `metric`. . [optional]
            lang (str): Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). . [optional] if omitted the server will use the default value of "en-US"
            _return ([ModelReturn]): Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.  * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.   Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified). * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section. * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language. * `summary` - Include summary for the section. * `travelSummary` - Include summary for the travel portion of the section. * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section. * `mlDuration` - Use a region-specific machine learning model to calculate route duration. **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.** * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`. * `routeHandle` - Encode calculated route and return a handle which can be used with   `routes/{routeHandle}` to decode the route at a later point in time. * `passthrough` - Include information on passthrough via waypoints in the section. * `incidents` - Include a list of all incidents applicable to each section.                 Incidents are localized to the requested language. * `routingZones` - Include information about routing zones each section goes through. * `tolls` - Include a summary of the tolls to be paid during each section according to the `tolls` parameter in the query. **Alpha** some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment. Therefore the request will return the most \"typical\" toll cost.  Following restrictions apply when specifying return parameter:  * If `actions` is requested, then `polyline` must also be requested as well. * If `instructions` is requested, then `actions` must also be requested as well. * If `turnByTurnActions` is requested, then `polyline` must also be requested as well. * If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well . [optional]
            spans ([Spans]): Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response.  This parameter also requires that the `polyline` option is set within the `return` parameter. . [optional]
            truck (Truck): Truck specific parameters.   * `shippedHazardousGoods`:     Comma-separated list of shipped hazardous goods in the vehicle.     Possible values are:     * `explosive`: Explosive material     * `gas`: Gas     * `flammable`: Flammable material     * `combustible`: Combustible material     * `organic`: Organic material     * `poison`: Poison     * `radioactive`: Radioactive material     * `corrosive`: Corrosive material     * `poisonousInhalation`: Materials that are poisonous upon inhalation     * `harmfulToWater`: Materials that are harmful to water     * `other`: Other types of hazardous materials   * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.   * `weightPerAxle`: Vehicle weight per axle, in kilograms.   * `height`: Vehicle height, in centimeters.   * `width`: Vehicle width, in centimeters.   * `length`: Vehicle length, in centimeters.   * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.     Possible values:       * `B`       * `C`       * `D`       * `E`   * `axleCount`: Defines total number of axles in the vehicle.   * `type`: Specifies the type of truck       * `straight`: a truck on a single frame with a permanently attached cargo area       * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)   * `trailerCount`: Number of trailers attached to the vehicle. . [optional]
            ev (EV): [optional]
            vehicle (Vehicle): [optional]
            pedestrian_speed (PedestrianSpeed): **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. . [optional]
            x_request_id (str): User-provided token that can be used to trace a request or a group of requests sent to the service.. [optional]
            scooter (Scooter): Scooter specific parameters.   * `allowHighway`: Specifies whether scooter is allowed on highway or not. This parameter is optional.     If not provided, then by default scooter is not allowed to use highway.     There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage.     avoid[features] takes precedence so if this parameter is also used then scooters are not allowed     to use highways even if `allowHighway` is used with value as true.     Possible values:       * `true`: scooter is allowed to use highway.       * `false`: scooter is not allowed to use highway. . [optional]
            currency (str): Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            RouterRouteResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['transport_mode'] = \
            transport_mode
        kwargs['origin'] = \
            origin
        kwargs['destination'] = \
            destination
        return self.calculate_routes_endpoint.call_with_http_info(**kwargs)

    def calculate_routes_post(
        self,
        transport_mode,
        origin,
        destination,
        **kwargs
    ):
        """Calculate routes via POST  # noqa: E501

        **Note** : This functionality is *Coming Soon*  Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...  Parameters can be provided either in the query string or in the POST body. If a parameter is provided in both, the request will fail.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.calculate_routes_post(transport_mode, origin, destination, async_req=True)
        >>> result = thread.get()

        Args:
            transport_mode (RouterMode): Mode of transport to be used for the calculation of the route.  Note: `taxi` and `bus` modes are in Alpha state. They are not yet stable and behaviour may change drastically, or even become unsupported, without warning. `taxi` and `bus` modes take into account taxi/bus restricted streets as well as streets reserved for exclusive taxi/bus access. It does not, however, consider exclusive lanes in otherwise shared streets. Also, the streets that are for exclusive access for taxi/bus are used only if either the origin or destination are on them. 
            origin (str): A location defining the origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Asks the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 
            destination (str): A location defining the destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Asks the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. * `passThrough`: option is not supported for 'destination'.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 

        Keyword Args:
            via ([str]): A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  Multiple waypoints can also be specified using multiple via parameters like `via=...&via=...`, in which case the route will traverse these waypoints sequentially in the order specified in the request.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Asks the routing service to try find a route that avoids actions for   the indicated distance. E.g. if the origin is determined by a moving vehicle, the user   might not have time to react to early actions.  Supported waypoint options: * `stopDuration`: desired duration for the stop, in seconds. * `passThrough`: boolean. Asks the router to avoid the following during route calculation:   + Introducing a stop at the waypoint.   + Splitting the route into sections.   + Changing the direction of travel.    Following scenarios are not supported for `passThrough` parameter:   + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.   + Setting `passThrough=true` for `origin` or `destination` of a route.   The default value is `false`.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. . [optional]
            departure_time (str): Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. . [optional]
            routing_mode (RoutingMode): Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance.  Notes: * The following Transport modes only support `fast` routingMode   - `bicycle`   - `bus`   - `pedestrian`   - `scooter`   - `taxi` . [optional]
            alternatives (int): Number of alternative routes to return aside from the optimal route.. [optional] if omitted the server will use the default value of 0
            avoid (Avoid): Avoid routes that violate certain features of road network or that go through user-specified geographical bounding boxes.  Note that if the origin, destination, or any via is in an avoided area or on an avoided feature, a route is produced that violates the avoid restriction. In such a case, the route is trying to minimize the violation of the avoid restrictions and can therefore include large deviations from a route that is calculated without these avoid restrictions.  It is also possible that the produced route violates the avoid restriction in between waypoints, if no other route is possible or too hard to find. One such example is requesting a route to an island that is only reachable with ferries while specifying `avoid[features]=ferry`.  Further, avoid can cause the route calculation to fail, if no route is possible or too hard to find.  Specify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel`. . [optional]
            exclude (Exclude): Defines properties which will be strictly excluded from route calculation. . [optional]
            units (Units): Units of measurement used in guidance instructions. The default is `metric`. . [optional]
            lang (str): Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). . [optional] if omitted the server will use the default value of "en-US"
            _return ([ModelReturn]): Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.  * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.   Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified). * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section. * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language. * `summary` - Include summary for the section. * `travelSummary` - Include summary for the travel portion of the section. * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section. * `mlDuration` - Use a region-specific machine learning model to calculate route duration. **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.** * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`. * `routeHandle` - Encode calculated route and return a handle which can be used with   `routes/{routeHandle}` to decode the route at a later point in time. * `passthrough` - Include information on passthrough via waypoints in the section. * `incidents` - Include a list of all incidents applicable to each section.                 Incidents are localized to the requested language. * `routingZones` - Include information about routing zones each section goes through. * `tolls` - Include a summary of the tolls to be paid during each section according to the `tolls` parameter in the query. **Alpha** some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment. Therefore the request will return the most \"typical\" toll cost.  Following restrictions apply when specifying return parameter:  * If `actions` is requested, then `polyline` must also be requested as well. * If `instructions` is requested, then `actions` must also be requested as well. * If `turnByTurnActions` is requested, then `polyline` must also be requested as well. * If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well . [optional]
            spans ([Spans]): Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response.  This parameter also requires that the `polyline` option is set within the `return` parameter. . [optional]
            truck (Truck): Truck specific parameters.   * `shippedHazardousGoods`:     Comma-separated list of shipped hazardous goods in the vehicle.     Possible values are:     * `explosive`: Explosive material     * `gas`: Gas     * `flammable`: Flammable material     * `combustible`: Combustible material     * `organic`: Organic material     * `poison`: Poison     * `radioactive`: Radioactive material     * `corrosive`: Corrosive material     * `poisonousInhalation`: Materials that are poisonous upon inhalation     * `harmfulToWater`: Materials that are harmful to water     * `other`: Other types of hazardous materials   * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.   * `weightPerAxle`: Vehicle weight per axle, in kilograms.   * `height`: Vehicle height, in centimeters.   * `width`: Vehicle width, in centimeters.   * `length`: Vehicle length, in centimeters.   * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.     Possible values:       * `B`       * `C`       * `D`       * `E`   * `axleCount`: Defines total number of axles in the vehicle.   * `type`: Specifies the type of truck       * `straight`: a truck on a single frame with a permanently attached cargo area       * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)   * `trailerCount`: Number of trailers attached to the vehicle. . [optional]
            ev (EV): [optional]
            vehicle (Vehicle): [optional]
            pedestrian_speed (PedestrianSpeed): **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. . [optional]
            x_request_id (str): User-provided token that can be used to trace a request or a group of requests sent to the service.. [optional]
            scooter (Scooter): Scooter specific parameters.   * `allowHighway`: Specifies whether scooter is allowed on highway or not. This parameter is optional.     If not provided, then by default scooter is not allowed to use highway.     There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage.     avoid[features] takes precedence so if this parameter is also used then scooters are not allowed     to use highways even if `allowHighway` is used with value as true.     Possible values:       * `true`: scooter is allowed to use highway.       * `false`: scooter is not allowed to use highway. . [optional]
            calculate_routes_parameters (CalculateRoutesParameters): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            RouterRouteResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['transport_mode'] = \
            transport_mode
        kwargs['origin'] = \
            origin
        kwargs['destination'] = \
            destination
        return self.calculate_routes_post_endpoint.call_with_http_info(**kwargs)

    def get_routes_by_handle(
        self,
        route_handle,
        transport_mode,
        **kwargs
    ):
        """Get route by handle  # noqa: E501

        Decodes and returns a route from a previously calculated route handle.  **Alpha**: This API is not yet stable and is subject to change.  A route handle encodes a previously calculated route. A route can be decoded from a handle as long the service uses the same map data which was used during encoding.  All parameters of the `/routes` endpoint are supported, except for `destination`, `via`, `alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.  The `origin` parameter can be provided to update the start of the previously calculated route.  The `transportMode` parameter does not have to match the transport mode previously used for route calculation. However, when using a different transport mode, the request may fail, e.g. when the route has road segments forbidden for the provided transport mode.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_routes_by_handle(route_handle, transport_mode, async_req=True)
        >>> result = thread.get()

        Args:
            route_handle (str): Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information. 
            transport_mode (RouterMode): Mode of transport to be used for the calculation of the route.  Note: `taxi` and `bus` modes are in Alpha state. They are not yet stable and behaviour may change drastically, or even become unsupported, without warning. `taxi` and `bus` modes take into account taxi/bus restricted streets as well as streets reserved for exclusive taxi/bus access. It does not, however, consider exclusive lanes in otherwise shared streets. Also, the streets that are for exclusive access for taxi/bus are used only if either the origin or destination are on them. 

        Keyword Args:
            origin (str): A location defining the origin of the trip. The origin has to be located along the previously calculated route.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. * `minCourseDistance`: While this parameter can be provided for compatibility reasons,   it will not affect the result of a getRoutesByHandle request. . [optional]
            departure_time (str): Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. . [optional]
            avoid (Avoid): Avoid routes that violate certain features of road network or that go through user-specified geographical bounding boxes.  Note that if the origin, destination, or any via is in an avoided area or on an avoided feature, a route is produced that violates the avoid restriction. In such a case, the route is trying to minimize the violation of the avoid restrictions and can therefore include large deviations from a route that is calculated without these avoid restrictions.  It is also possible that the produced route violates the avoid restriction in between waypoints, if no other route is possible or too hard to find. One such example is requesting a route to an island that is only reachable with ferries while specifying `avoid[features]=ferry`.  Further, avoid can cause the route calculation to fail, if no route is possible or too hard to find.  Specify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel`. . [optional]
            exclude (Exclude): Defines properties which will be strictly excluded from route calculation. . [optional]
            units (Units): Units of measurement used in guidance instructions. The default is `metric`. . [optional]
            lang (str): Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). . [optional] if omitted the server will use the default value of "en-US"
            _return ([ModelReturn]): Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.  * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.   Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified). * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section. * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language. * `summary` - Include summary for the section. * `travelSummary` - Include summary for the travel portion of the section. * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section. * `mlDuration` - Use a region-specific machine learning model to calculate route duration. **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.** * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`. * `routeHandle` - Encode calculated route and return a handle which can be used with   `routes/{routeHandle}` to decode the route at a later point in time. * `passthrough` - Include information on passthrough via waypoints in the section. * `incidents` - Include a list of all incidents applicable to each section.                 Incidents are localized to the requested language. * `routingZones` - Include information about routing zones each section goes through. * `tolls` - Include a summary of the tolls to be paid during each section according to the `tolls` parameter in the query. **Alpha** some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment. Therefore the request will return the most \"typical\" toll cost.  Following restrictions apply when specifying return parameter:  * If `actions` is requested, then `polyline` must also be requested as well. * If `instructions` is requested, then `actions` must also be requested as well. * If `turnByTurnActions` is requested, then `polyline` must also be requested as well. * If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well . [optional]
            spans ([Spans]): Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response.  This parameter also requires that the `polyline` option is set within the `return` parameter. . [optional]
            truck (Truck): Truck specific parameters.   * `shippedHazardousGoods`:     Comma-separated list of shipped hazardous goods in the vehicle.     Possible values are:     * `explosive`: Explosive material     * `gas`: Gas     * `flammable`: Flammable material     * `combustible`: Combustible material     * `organic`: Organic material     * `poison`: Poison     * `radioactive`: Radioactive material     * `corrosive`: Corrosive material     * `poisonousInhalation`: Materials that are poisonous upon inhalation     * `harmfulToWater`: Materials that are harmful to water     * `other`: Other types of hazardous materials   * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.   * `weightPerAxle`: Vehicle weight per axle, in kilograms.   * `height`: Vehicle height, in centimeters.   * `width`: Vehicle width, in centimeters.   * `length`: Vehicle length, in centimeters.   * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.     Possible values:       * `B`       * `C`       * `D`       * `E`   * `axleCount`: Defines total number of axles in the vehicle.   * `type`: Specifies the type of truck       * `straight`: a truck on a single frame with a permanently attached cargo area       * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)   * `trailerCount`: Number of trailers attached to the vehicle. . [optional]
            ev (EV): [optional]
            vehicle (Vehicle): [optional]
            x_request_id (str): User-provided token that can be used to trace a request or a group of requests sent to the service.. [optional]
            scooter (Scooter): Scooter specific parameters.   * `allowHighway`: Specifies whether scooter is allowed on highway or not. This parameter is optional.     If not provided, then by default scooter is not allowed to use highway.     There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage.     avoid[features] takes precedence so if this parameter is also used then scooters are not allowed     to use highways even if `allowHighway` is used with value as true.     Possible values:       * `true`: scooter is allowed to use highway.       * `false`: scooter is not allowed to use highway. . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            RouterRouteResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['route_handle'] = \
            route_handle
        kwargs['transport_mode'] = \
            transport_mode
        return self.get_routes_by_handle_endpoint.call_with_http_info(**kwargs)

    def get_routes_by_handle_post(
        self,
        route_handle,
        transport_mode,
        **kwargs
    ):
        """Get route by handle via POST  # noqa: E501

        Decodes and returns a route from a previously calculated route handle.  **Alpha**: This API is coming soon. It may not be stable and is subject to change.  A route handle encodes a previously calculated route. A route can be decoded from a handle as long the service uses the same map data which was used during encoding.  All parameters of the `/routes` endpoint are supported, except for `destination`, `via`, `alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.  The `origin` parameter can be provided to update the start of the previously calculated route.  The `transportMode` parameter does not have to match the transport mode previously used for route calculation. However, when using a different transport mode, the request may fail, e.g. when the route has road segments forbidden for the provided transport mode.  Parameters can be provided either in the query string or in the POST body. If a parameter is provided in both, the request will fail.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_routes_by_handle_post(route_handle, transport_mode, async_req=True)
        >>> result = thread.get()

        Args:
            route_handle (str): Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information. 
            transport_mode (RouterMode): Mode of transport to be used for the calculation of the route.  Note: `taxi` and `bus` modes are in Alpha state. They are not yet stable and behaviour may change drastically, or even become unsupported, without warning. `taxi` and `bus` modes take into account taxi/bus restricted streets as well as streets reserved for exclusive taxi/bus access. It does not, however, consider exclusive lanes in otherwise shared streets. Also, the streets that are for exclusive access for taxi/bus are used only if either the origin or destination are on them. 

        Keyword Args:
            origin (str): A location defining the origin of the trip. The origin has to be located along the previously calculated route.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. * `minCourseDistance`: While this parameter can be provided for compatibility reasons,   it will not affect the result of a getRoutesByHandle request. . [optional]
            departure_time (str): Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. . [optional]
            avoid (Avoid): Avoid routes that violate certain features of road network or that go through user-specified geographical bounding boxes.  Note that if the origin, destination, or any via is in an avoided area or on an avoided feature, a route is produced that violates the avoid restriction. In such a case, the route is trying to minimize the violation of the avoid restrictions and can therefore include large deviations from a route that is calculated without these avoid restrictions.  It is also possible that the produced route violates the avoid restriction in between waypoints, if no other route is possible or too hard to find. One such example is requesting a route to an island that is only reachable with ferries while specifying `avoid[features]=ferry`.  Further, avoid can cause the route calculation to fail, if no route is possible or too hard to find.  Specify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel`. . [optional]
            exclude (Exclude): Defines properties which will be strictly excluded from route calculation. . [optional]
            units (Units): Units of measurement used in guidance instructions. The default is `metric`. . [optional]
            lang (str): Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). . [optional] if omitted the server will use the default value of "en-US"
            _return ([ModelReturn]): Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.  * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.   Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified). * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section. * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language. * `summary` - Include summary for the section. * `travelSummary` - Include summary for the travel portion of the section. * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section. * `mlDuration` - Use a region-specific machine learning model to calculate route duration. **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.** * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`. * `routeHandle` - Encode calculated route and return a handle which can be used with   `routes/{routeHandle}` to decode the route at a later point in time. * `passthrough` - Include information on passthrough via waypoints in the section. * `incidents` - Include a list of all incidents applicable to each section.                 Incidents are localized to the requested language. * `routingZones` - Include information about routing zones each section goes through. * `tolls` - Include a summary of the tolls to be paid during each section according to the `tolls` parameter in the query. **Alpha** some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment. Therefore the request will return the most \"typical\" toll cost.  Following restrictions apply when specifying return parameter:  * If `actions` is requested, then `polyline` must also be requested as well. * If `instructions` is requested, then `actions` must also be requested as well. * If `turnByTurnActions` is requested, then `polyline` must also be requested as well. * If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well . [optional]
            spans ([Spans]): Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response.  This parameter also requires that the `polyline` option is set within the `return` parameter. . [optional]
            truck (Truck): Truck specific parameters.   * `shippedHazardousGoods`:     Comma-separated list of shipped hazardous goods in the vehicle.     Possible values are:     * `explosive`: Explosive material     * `gas`: Gas     * `flammable`: Flammable material     * `combustible`: Combustible material     * `organic`: Organic material     * `poison`: Poison     * `radioactive`: Radioactive material     * `corrosive`: Corrosive material     * `poisonousInhalation`: Materials that are poisonous upon inhalation     * `harmfulToWater`: Materials that are harmful to water     * `other`: Other types of hazardous materials   * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.   * `weightPerAxle`: Vehicle weight per axle, in kilograms.   * `height`: Vehicle height, in centimeters.   * `width`: Vehicle width, in centimeters.   * `length`: Vehicle length, in centimeters.   * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.     Possible values:       * `B`       * `C`       * `D`       * `E`   * `axleCount`: Defines total number of axles in the vehicle.   * `type`: Specifies the type of truck       * `straight`: a truck on a single frame with a permanently attached cargo area       * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)   * `trailerCount`: Number of trailers attached to the vehicle. . [optional]
            ev (EV): [optional]
            vehicle (Vehicle): [optional]
            x_request_id (str): User-provided token that can be used to trace a request or a group of requests sent to the service.. [optional]
            scooter (Scooter): Scooter specific parameters.   * `allowHighway`: Specifies whether scooter is allowed on highway or not. This parameter is optional.     If not provided, then by default scooter is not allowed to use highway.     There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage.     avoid[features] takes precedence so if this parameter is also used then scooters are not allowed     to use highways even if `allowHighway` is used with value as true.     Possible values:       * `true`: scooter is allowed to use highway.       * `false`: scooter is not allowed to use highway. . [optional]
            get_routes_by_handle_parameters (GetRoutesByHandleParameters): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            RouterRouteResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['route_handle'] = \
            route_handle
        kwargs['transport_mode'] = \
            transport_mode
        return self.get_routes_by_handle_post_endpoint.call_with_http_info(**kwargs)

    def import_route(
        self,
        transport_mode,
        **kwargs
    ):
        """Calculate a route from a sequence of trace points  # noqa: E501

        Creates a route from a sequence of trace points.  **Alpha**: This API is coming soon. It may not be stable and is subject to change.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.import_route(transport_mode, async_req=True)
        >>> result = thread.get()

        Args:
            transport_mode (RouterMode): Mode of transport to be used for the calculation of the route.  Note: `taxi` and `bus` modes are in Alpha state. They are not yet stable and behaviour may change drastically, or even become unsupported, without warning. `taxi` and `bus` modes take into account taxi/bus restricted streets as well as streets reserved for exclusive taxi/bus access. It does not, however, consider exclusive lanes in otherwise shared streets. Also, the streets that are for exclusive access for taxi/bus are used only if either the origin or destination are on them. 

        Keyword Args:
            departure_time (str): Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. . [optional]
            avoid (Avoid): Avoid routes that violate certain features of road network or that go through user-specified geographical bounding boxes.  Note that if the origin, destination, or any via is in an avoided area or on an avoided feature, a route is produced that violates the avoid restriction. In such a case, the route is trying to minimize the violation of the avoid restrictions and can therefore include large deviations from a route that is calculated without these avoid restrictions.  It is also possible that the produced route violates the avoid restriction in between waypoints, if no other route is possible or too hard to find. One such example is requesting a route to an island that is only reachable with ferries while specifying `avoid[features]=ferry`.  Further, avoid can cause the route calculation to fail, if no route is possible or too hard to find.  Specify properties using array notation like `avoid[features]=controlledAccessHighway,tunnel`. . [optional]
            exclude (Exclude): Defines properties which will be strictly excluded from route calculation. . [optional]
            units (Units): Units of measurement used in guidance instructions. The default is `metric`. . [optional]
            lang (str): Specifies the preferred language of the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). . [optional] if omitted the server will use the default value of "en-US"
            _return ([ModelReturn]): Defines which attributes are included in the response as part of data representation of a `Route` or `Section`.  * `polyline` - Polyline for the route in [Flexible Polyline](https://github.com/heremaps/flexible-polyline) Encoding.   Either a 2D polyline (without `elevation` specified), or a 3D polyline with the 3rd dimension type `Elevation` (with `elevation` specified). * `actions` - Actions (such as maneuvers or tasks) that must be taken to complete the section. * `instructions` - Include instructions in returned actions. Instructions are localized to the requested language. * `summary` - Include summary for the section. * `travelSummary` - Include summary for the travel portion of the section. * `turnByTurnActions` - Include all information necessary to support turn by turn guidance to complete the section. * `mlDuration` - Use a region-specific machine learning model to calculate route duration. **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes.** * `elevation` - Include elevation information in coordinate and geometry types. See e.g. `polyline` or `location`. * `routeHandle` - Encode calculated route and return a handle which can be used with   `routes/{routeHandle}` to decode the route at a later point in time. * `passthrough` - Include information on passthrough via waypoints in the section. * `incidents` - Include a list of all incidents applicable to each section.                 Incidents are localized to the requested language. * `routingZones` - Include information about routing zones each section goes through. * `tolls` - Include a summary of the tolls to be paid during each section according to the `tolls` parameter in the query. **Alpha** some toll-related options such as cars with trailers, or vehicle fuel related tolls are planned but not implemented at the moment. Therefore the request will return the most \"typical\" toll cost.  Following restrictions apply when specifying return parameter:  * If `actions` is requested, then `polyline` must also be requested as well. * If `instructions` is requested, then `actions` must also be requested as well. * If `turnByTurnActions` is requested, then `polyline` must also be requested as well. * If at least one attribute is requested within the `spans` parameter, then `polyline` must be request as well . [optional]
            spans ([Spans]): Defines which attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response.  This parameter also requires that the `polyline` option is set within the `return` parameter. . [optional]
            truck (Truck): Truck specific parameters.   * `shippedHazardousGoods`:     Comma-separated list of shipped hazardous goods in the vehicle.     Possible values are:     * `explosive`: Explosive material     * `gas`: Gas     * `flammable`: Flammable material     * `combustible`: Combustible material     * `organic`: Organic material     * `poison`: Poison     * `radioactive`: Radioactive material     * `corrosive`: Corrosive material     * `poisonousInhalation`: Materials that are poisonous upon inhalation     * `harmfulToWater`: Materials that are harmful to water     * `other`: Other types of hazardous materials   * `grossWeight`: Vehicle weight including trailers and shipped goods, in kilograms.   * `weightPerAxle`: Vehicle weight per axle, in kilograms.   * `height`: Vehicle height, in centimeters.   * `width`: Vehicle width, in centimeters.   * `length`: Vehicle length, in centimeters.   * `tunnelCategory`: Specifies the tunnel category used to restrict transport of specific goods.     Possible values:       * `B`       * `C`       * `D`       * `E`   * `axleCount`: Defines total number of axles in the vehicle.   * `type`: Specifies the type of truck       * `straight`: a truck on a single frame with a permanently attached cargo area       * `tractor`: a towing vehicle that can pull one or more semi-trailers (aka semi-truck)   * `trailerCount`: Number of trailers attached to the vehicle. . [optional]
            ev (EV): [optional]
            vehicle (Vehicle): [optional]
            x_request_id (str): User-provided token that can be used to trace a request or a group of requests sent to the service.. [optional]
            scooter (Scooter): Scooter specific parameters.   * `allowHighway`: Specifies whether scooter is allowed on highway or not. This parameter is optional.     If not provided, then by default scooter is not allowed to use highway.     There is a similar parameter avoid[features]=controlledAccessHighway to disallow highway usage.     avoid[features] takes precedence so if this parameter is also used then scooters are not allowed     to use highways even if `allowHighway` is used with value as true.     Possible values:       * `true`: scooter is allowed to use highway.       * `false`: scooter is not allowed to use highway. . [optional]
            match_trace (MatchTrace): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['transport_mode'] = \
            transport_mode
        return self.import_route_endpoint.call_with_http_info(**kwargs)

